Assignment 7 (Graduate): Ray Tracing with KD-Tree Acceleration

This project implements a complete ray-tracing program in C++ capable of rendering complex triangle meshes using a KD-tree acceleration structure and a full Phong lighting model.

1. Project Overview

The core program (Scenegraphs) integrates a new ray tracer alongside the existing OpenGL renderer. The ray tracer uses a scene graph for object placement and transformation, and a KD-tree for fast intersection testing with polygon meshes.

Key Components:

Mode Switch: Press the 'S' key to switch from OpenGL display to Ray Tracing mode.

Output: Ray tracer output is written to PPM image files within the dedicated images/ directory.

Efficiency: KD-trees are utilized to optimize the ray-triangle intersection process, dramatically speeding up rendering of large meshes.

2. Implementation Details

2.1 Foundational Classes (1.1)

Ray: Defines a 3D ray with an origin point and a direction vector.

HitRecord: Stores the essential data for a ray-object intersection, including:

t: Time of intersection.

point: 3D coordinates in view space.

normal: 3D normal vector in view space.

material: Object's material properties.

u, v: Barycentric coordinates for normal interpolation.

RaytraceRenderer / SceneRaytracer: The main class responsible for setting up the camera, iterating over pixels, casting the primary rays, and writing the final PPM output.

2.2 Scene Graph Integration (1.4)

The ray casting process (HitRecord raycast(Ray ray)) is integrated directly into the Scene Graph structure:

Node Type

Ray Casting Logic

TransformNode

Transforms the incoming ray into the node's local coordinate system (using the inverse modelview matrix) before delegating to children.

GroupNode

Delegates the ray to all children and returns the closest positive HitRecord found among them.

LeafNode

Processes the ray using the associated RaytraceMesh object.

RaytraceMesh

Contains the KDTree for the mesh and initiates the KD-tree traversal.

2.3 KD-Tree Acceleration (2)

The KDTree.cpp implements the spatial acceleration structure and intersection logic.

Triangle Storage (2.1): The tree construction process correctly assigns triangles to both leaf nodes and internal nodes (for triangles lying exactly on the split plane).

Ray Traversal (2.2): The rayTrace function traverses the tree in an optimized front-to-back order with respect to the ray's starting point.

Bounding Box Check (2.2.3): The ray is first tested against the tree's overall bounding box to clip the ray's t_min and t_max, avoiding traversal if the object is missed.

Intersection: The function performs a highly accurate  MÃ¶ller-Trumbore ray-triangle intersection test.

2.4 Shading and Normals (3)

The lighting calculation replicates the Phong illumination model:

Lighting Model: Supports Point, Directional, and Spot light sources, demonstrating the proper calculation for the fall-off cone angle in the spotlight test (spotlight.cpp).

Shading: Calculates Ambient, Diffuse, and Specular components.

Smooth Normals (3.1): The barycentric coordinates (u, v) obtained during intersection are used to perform bilinear interpolation of the vertex normals to compute a smooth normal vector at the intersection point, crucial for realistic shading on curved surfaces (like the spheres in sphere.cpp).

3. Building and Running

Prerequisites

C++ compiler (e.g., g++).

make utility.

Required libraries (GLM, OpenGL/GLAD).

Build Instructions

Navigate to the project directory in your terminal.

Run make to compile the source files:

make


Run Instructions

The program requires a scene command file as a command-line argument.

./Scenegraphs <command-file.txt>


Ray Tracing Output & Image Folder

Run the program with a scene file (e.g., ./Scenegraphs final_scene.cpp).

Once the OpenGL window appears, press the 'S' key to trigger the ray tracing process.

The ray tracer will automatically save its output to the images/ directory.

NOTE: You must create the images/ folder in the root directory before running the program, or the file save will fail.

4. Required Submission Images

All required images are generated by the provided test files and are saved to the images/ directory.

Requirement

Test File

Output Image File

Final Rendering

final_scene.cpp

images/final_scene.ppm

Sphere Test

sphere.cpp

images/sphere_test.ppm

Box Test

box.cpp

images/box_test.ppm

Spotlight Test

spotlight.cpp

images/spotlight_test.ppm

Extra Credit

extra_credit.cpp

images/extra_credit.ppm

OpenGL Screenshot

(Manual Screenshot from OpenGL mode)

images/final_scene_opengl.png

5. Extra Credit: Creative Modeling (5 Points)

The scene implemented in extra_credit.cpp demonstrates the ray tracer's capabilities with a complex, meaningful, and creative arrangement.

Scene Theme: A stylized Solar System / Astronomical Display.

Object Count: Exceeds the required 15 objects (Total of 15+ objects).

Complex Model: The aeroplane-scaled.obj model is loaded and positioned at the center, serving as a large, static "space station" or "asteroid."

Arrangement: Multiple spheres are positioned as colorful "planets" orbiting the center, showcasing complex transformations (scaling and rotation/translation) and varied material properties.

The output image for this feature is images/extra_credit.ppm.
